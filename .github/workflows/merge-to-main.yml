name: Post-Merge Actions

on:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - 'databricks.yml'

jobs:
  tag-release:
    runs-on: ubuntu-latest
    name: Tag Release and Prepare for TEST
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Get commit info
        id: commit
        run: |
          echo "sha_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "message=$(git log -1 --pretty=%B | head -n 1)" >> $GITHUB_OUTPUT
          echo "author=$(git log -1 --pretty=%an)" >> $GITHUB_OUTPUT
          echo "date=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_OUTPUT
      
      - name: Determine version tag
        id: version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Extract version numbers
          VERSION="${LATEST_TAG#v}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          # Increment patch version
          PATCH=$((PATCH + 1))
          NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
          
          echo "new_tag=${NEW_TAG}" >> $GITHUB_OUTPUT
          echo "New tag will be: ${NEW_TAG}"
      
      - name: Create release tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Create annotated tag
          git tag -a "${{ steps.version.outputs.new_tag }}" \
            -m "Release ${{ steps.version.outputs.new_tag }}" \
            -m "Commit: ${{ steps.commit.outputs.sha_short }}" \
            -m "Author: ${{ steps.commit.outputs.author }}" \
            -m "Message: ${{ steps.commit.outputs.message }}"
          
          # Push tag
          git push origin "${{ steps.version.outputs.new_tag }}"
      
      - name: Generate deployment summary
        id: summary
        run: |
          # Check what changed
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)
          
          SHARED_CHANGED=false
          UC1_CHANGED=false
          UC2_CHANGED=false
          
          if echo "$CHANGED_FILES" | grep -q "src/shared/"; then
            SHARED_CHANGED=true
          fi
          
          if echo "$CHANGED_FILES" | grep -q "src/usecase-1/"; then
            UC1_CHANGED=true
          fi
          
          if echo "$CHANGED_FILES" | grep -q "src/usecase-2/"; then
            UC2_CHANGED=true
          fi
          
          echo "shared_changed=${SHARED_CHANGED}" >> $GITHUB_OUTPUT
          echo "uc1_changed=${UC1_CHANGED}" >> $GITHUB_OUTPUT
          echo "uc2_changed=${UC2_CHANGED}" >> $GITHUB_OUTPUT
      
      - name: Create deployment issue
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš€ Ready for TEST Deployment - ${{ steps.version.outputs.new_tag }}`,
              body: `## Deployment Summary
              
              A new version has been merged to main and is ready for TEST deployment.
              
              ### Version Information
              - **Tag:** ${{ steps.version.outputs.new_tag }}
              - **Commit:** ${{ steps.commit.outputs.sha_short }}
              - **Author:** ${{ steps.commit.outputs.author }}
              - **Message:** ${{ steps.commit.outputs.message }}
              - **Date:** ${{ steps.commit.outputs.date }}
              
              ### Changes Detected
              - **Shared Folder:** ${{ steps.summary.outputs.shared_changed == 'true' && 'âœ… Changed' || 'â­• No changes' }}
              - **Use Case 1:** ${{ steps.summary.outputs.uc1_changed == 'true' && 'âœ… Changed' || 'â­• No changes' }}
              - **Use Case 2:** ${{ steps.summary.outputs.uc2_changed == 'true' && 'âœ… Changed' || 'â­• No changes' }}
              
              ### Next Steps
              1. Review the changes in the [commit](${{ github.event.head_commit.url }})
              2. Deploy to TEST environment using the [Deploy to TEST workflow](../../actions/workflows/deploy-test.yml)
              3. Select the appropriate use case(s) to deploy
              4. After successful TEST validation, deploy to PROD
              
              ### Deployment Commands
              To deploy to TEST, go to Actions â†’ Deploy to TEST â†’ Run workflow
              
              Remember: The shared folder will always be deployed along with your selected use case.`,
              labels: ['deployment', 'test-ready']
            });
            
            console.log(`Created issue #${issue.data.number}`);
      
      - name: Summary
        run: |
          echo "## ðŸŽ‰ Release Tagged Successfully" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Version Information" >> $GITHUB_STEP_SUMMARY
          echo "- **New Tag:** ${{ steps.version.outputs.new_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit:** ${{ steps.commit.outputs.sha_short }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Author:** ${{ steps.commit.outputs.author }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Deploy to TEST using the manual workflow" >> $GITHUB_STEP_SUMMARY
          echo "2. Validate in TEST environment" >> $GITHUB_STEP_SUMMARY
          echo "3. Deploy to PROD after successful testing" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** DEV environment was already updated during the PR validation phase." >> $GITHUB_STEP_SUMMARY